package reader

import (
	"context"
	
	"github.com/aws/aws-sdk-go-v2/service/apigateway"
	apigatewaytypes "github.com/aws/aws-sdk-go-v2/service/apigateway/types"
	"github.com/aws/aws-sdk-go-v2/service/athena"
	athenatypes "github.com/aws/aws-sdk-go-v2/service/athena/types"
	"github.com/aws/aws-sdk-go-v2/service/autoscaling"
	autoscalingtypes "github.com/aws/aws-sdk-go-v2/service/autoscaling/types"
	"github.com/aws/aws-sdk-go-v2/service/batch"
	batchtypes "github.com/aws/aws-sdk-go-v2/service/batch/types"
	"github.com/aws/aws-sdk-go-v2/service/cloudfront"
	cloudfronttypes "github.com/aws/aws-sdk-go-v2/service/cloudfront/types"
	"github.com/aws/aws-sdk-go-v2/service/cloudwatch"
	cloudwatchtypes "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
	"github.com/aws/aws-sdk-go-v2/service/configservice"
	configservicetypes "github.com/aws/aws-sdk-go-v2/service/configservice/types"
	"github.com/aws/aws-sdk-go-v2/service/databasemigrationservice"
	databasemigrationservicetypes "github.com/aws/aws-sdk-go-v2/service/databasemigrationservice/types"
	"github.com/aws/aws-sdk-go-v2/service/dax"
	daxtypes "github.com/aws/aws-sdk-go-v2/service/dax/types"
	"github.com/aws/aws-sdk-go-v2/service/directconnect"
	directconnecttypes "github.com/aws/aws-sdk-go-v2/service/directconnect/types"
	"github.com/aws/aws-sdk-go-v2/service/directoryservice"
	directoryservicetypes "github.com/aws/aws-sdk-go-v2/service/directoryservice/types"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	dynamodbtypes "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	ec2types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/aws/aws-sdk-go-v2/service/ecs"
	ecstypes "github.com/aws/aws-sdk-go-v2/service/ecs/types"
	"github.com/aws/aws-sdk-go-v2/service/efs"
	efstypes "github.com/aws/aws-sdk-go-v2/service/efs/types"
	"github.com/aws/aws-sdk-go-v2/service/eks"
	ekstypes "github.com/aws/aws-sdk-go-v2/service/eks/types"
	"github.com/aws/aws-sdk-go-v2/service/elasticache"
	elasticachetypes "github.com/aws/aws-sdk-go-v2/service/elasticache/types"
	"github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk"
	elasticbeanstalktypes "github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk/types"
	"github.com/aws/aws-sdk-go-v2/service/elasticloadbalancing"
	elasticloadbalancingtypes "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancing/types"
	"github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2"
	elasticloadbalancingv2types "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2/types"
	"github.com/aws/aws-sdk-go-v2/service/elasticsearchservice"
	elasticsearchservicetypes "github.com/aws/aws-sdk-go-v2/service/elasticsearchservice/types"
	"github.com/aws/aws-sdk-go-v2/service/emr"
	emrtypes "github.com/aws/aws-sdk-go-v2/service/emr/types"
	"github.com/aws/aws-sdk-go-v2/service/fsx"
	fsxtypes "github.com/aws/aws-sdk-go-v2/service/fsx/types"
	"github.com/aws/aws-sdk-go-v2/service/glue"
	gluetypes "github.com/aws/aws-sdk-go-v2/service/glue/types"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	iamtypes "github.com/aws/aws-sdk-go-v2/service/iam/types"
	"github.com/aws/aws-sdk-go-v2/service/kinesis"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	lambdatypes "github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/aws/aws-sdk-go-v2/service/lightsail"
	lightsailtypes "github.com/aws/aws-sdk-go-v2/service/lightsail/types"
	"github.com/aws/aws-sdk-go-v2/service/mediastore"
	mediastoretypes "github.com/aws/aws-sdk-go-v2/service/mediastore/types"
	"github.com/aws/aws-sdk-go-v2/service/mq"
	mqtypes "github.com/aws/aws-sdk-go-v2/service/mq/types"
	"github.com/aws/aws-sdk-go-v2/service/neptune"
	neptunetypes "github.com/aws/aws-sdk-go-v2/service/neptune/types"
	"github.com/aws/aws-sdk-go-v2/service/rds"
	rdstypes "github.com/aws/aws-sdk-go-v2/service/rds/types"
	"github.com/aws/aws-sdk-go-v2/service/redshift"
	redshifttypes "github.com/aws/aws-sdk-go-v2/service/redshift/types"
	"github.com/aws/aws-sdk-go-v2/service/route53"
	route53types "github.com/aws/aws-sdk-go-v2/service/route53/types"
	"github.com/aws/aws-sdk-go-v2/service/route53resolver"
	route53resolvertypes "github.com/aws/aws-sdk-go-v2/service/route53resolver/types"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	s3types "github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/aws/aws-sdk-go-v2/service/ses"
	sestypes "github.com/aws/aws-sdk-go-v2/service/ses/types"
	"github.com/aws/aws-sdk-go-v2/service/sqs"
	"github.com/aws/aws-sdk-go-v2/service/storagegateway"
	storagegatewaytypes "github.com/aws/aws-sdk-go-v2/service/storagegateway/types"
)

// Code generated by github.com/cycloidio/terracognita/aws/cmd; DO NOT EDIT

// Reader is the interface defining all methods that need to be implemented
//
// The next behavior commented in the below paragraph, applies to every method
// which clearly match what's explained, for the sake of not repeating the same,
// over and over.
// The most of the methods defined by this interface, return their results in a
// map. Those maps, have as keys, the AWS region which have been requested and
// the values are the items returned by AWS for such region.
// Because the methods may make calls to different regions, in case that there
// is an error on a region, the returned map won't have any entry for such
// region and such errors will be reported by the returned error, nonetheless
// the items, got from the successful requests to other regions, will be
// returned, with the meaning that the methods will return partial results, in
// case of errors.
// For avoiding by the callers the problem of if the returned map may be nil,
// the function will always return a map instance, which will be of length 0
// in case that there is not any successful request.
type Reader interface {
	// GetAccountID returns the current ID for the account used
	GetAccountID() string

	// GetRegion returns the currently used region for the Connector
	GetRegion() string

	// GetAPIGatewayDeployments returns the Deployment Functions on the given input
	// Returned values are commented in the interface doc comment block.
	GetAPIGatewayDeployments(ctx context.Context, input *apigateway.GetDeploymentsInput) ([]apigatewaytypes.Deployment, error)

	// GetAPIGatewayResources returns the Resource Functions on the given input
	// Returned values are commented in the interface doc comment block.
	GetAPIGatewayResources(ctx context.Context, input *apigateway.GetResourcesInput) ([]apigatewaytypes.Resource, error)

	// GetAPIGatewayRestAPIs returns the RestApi Functions on the given input
	// Returned values are commented in the interface doc comment block.
	GetAPIGatewayRestAPIs(ctx context.Context, input *apigateway.GetRestApisInput) ([]apigatewaytypes.RestApi, error)

	// GetAPIGatewayStages returns the Stage Functions on the given input
	// Returned values are commented in the interface doc comment block.
	GetAPIGatewayStages(ctx context.Context, input *apigateway.GetStagesInput) ([]apigatewaytypes.Stage, error)

	// GetAthenaDataCatalogs returns the Athena worker groups on the given input
	// Returned values are commented in the interface doc comment block.
	GetAthenaWorkGroups(ctx context.Context, input *athena.ListWorkGroupsInput) ([]athenatypes.WorkGroupSummary, error)

	// GetAutoScalingGroups returns all AutoScalingGroup belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetAutoScalingGroups(ctx context.Context, input *autoscaling.DescribeAutoScalingGroupsInput) ([]autoscalingtypes.AutoScalingGroup, error)

	// GetLaunchConfigurations returns all LaunchConfiguration belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetLaunchConfigurations(ctx context.Context, input *autoscaling.DescribeLaunchConfigurationsInput) ([]autoscalingtypes.LaunchConfiguration, error)

	// GetAutoScalingPolicies returns all AutoScalingPolicies belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetAutoScalingPolicies(ctx context.Context, input *autoscaling.DescribePoliciesInput) ([]autoscalingtypes.ScalingPolicy, error)

	// GetAutoScalingScheduledActions returns all ScheduledActions based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetAutoScalingScheduledActions(ctx context.Context, input *autoscaling.DescribeScheduledActionsInput) ([]autoscalingtypes.ScheduledUpdateGroupAction, error)

	// GetBatchJobDefinitions returns the batch jobs on the given input
	// Returned values are commented in the interface doc comment block.
	GetBatchJobDefinitions(ctx context.Context, input *batch.DescribeJobDefinitionsInput) ([]batchtypes.JobDefinition, error)

	// GetCloudFrontDistributions returns all the CloudFront Distributions on the given input
	// Returned values are commented in the interface doc comment block.
	GetCloudFrontDistributions(ctx context.Context, input *cloudfront.ListDistributionsInput) ([]cloudfronttypes.DistributionSummary, error)

	// GetCloudFrontOriginAccessIdentities returns all the CloudFront Origin Access Identities on the given input
	// Returned values are commented in the interface doc comment block.
	GetCloudFrontOriginAccessIdentities(ctx context.Context, input *cloudfront.ListCloudFrontOriginAccessIdentitiesInput) ([]cloudfronttypes.CloudFrontOriginAccessIdentitySummary, error)

	// GetCloudFrontPublicKeys returns all the CloudFront Public Keys on the given input
	// Returned values are commented in the interface doc comment block.
	GetCloudFrontPublicKeys(ctx context.Context, input *cloudfront.ListPublicKeysInput) ([]cloudfronttypes.PublicKeySummary, error)

	// GetMetricAlarms returns all cloudwatch alarms based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetMetricAlarms(ctx context.Context, input *cloudwatch.DescribeAlarmsInput) ([]cloudwatchtypes.MetricAlarm, error)

	// GetRecordedResourceCounts returns counts of the AWS resources which have
	// been recorded by AWS Config.
	// See https://docs.aws.amazon.com/config/latest/APIReference/API_GetDiscoveredResourceCounts.html
	// for more information about what to enable in your AWS account, the list of
	// supported resources, etc.
	GetRecordedResourceCounts(ctx context.Context, input *configservice.GetDiscoveredResourceCountsInput) ([]configservicetypes.ResourceCount, error)

	// GetDAXClusters returns the DAX clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetDAXClusters(ctx context.Context, input *dax.DescribeClustersInput) ([]daxtypes.Cluster, error)

	// GetDirectConnectGateways returns the Direct Connect gateways on the given input
	// Returned values are commented in the interface doc comment block.
	GetDirectConnectGateways(ctx context.Context, input *directconnect.DescribeDirectConnectGatewaysInput) ([]directconnecttypes.DirectConnectGateway, error)

	// GetDirectoryServiceDirectories returns the Directory Service directorie on the given input
	// Returned values are commented in the interface doc comment block.
	GetDirectoryServiceDirectories(ctx context.Context, input *directoryservice.DescribeDirectoriesInput) ([]directoryservicetypes.DirectoryDescription, error)

	// GetDMSDescribeReplicationInstances returns the DMS replication instances on the given input
	// Returned values are commented in the interface doc comment block.
	GetDMSDescribeReplicationInstances(ctx context.Context, input *databasemigrationservice.DescribeReplicationInstancesInput) ([]databasemigrationservicetypes.ReplicationInstance, error)

	// GetDynamodbGlobalTables returns the dynamodb global tables on the given input
	// Returned values are commented in the interface doc comment block.
	GetDynamodbGlobalTables(ctx context.Context, input *dynamodb.ListGlobalTablesInput) ([]dynamodbtypes.GlobalTable, error)

	// GetDynamodbTables returns the dynamodb talbles on the given input
	// Returned values are commented in the interface doc comment block.
	GetDynamodbTables(ctx context.Context, input *dynamodb.ListTablesInput) ([]string, error)

	// GetAddresses returns all EC2 Addresses based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetAddresses(ctx context.Context, input *ec2.DescribeAddressesInput) ([]ec2types.Address, error)

	// GetImages returns all EC2 AMI based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetImages(ctx context.Context, input *ec2.DescribeImagesInput) ([]ec2types.Image, error)

	// GetOwnImages returns all EC2 AMI belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetOwnImages(ctx context.Context, input *ec2.DescribeImagesInput) ([]ec2types.Image, error)

	// GetInstances returns all EC2 instances based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetInstances(ctx context.Context, input *ec2.DescribeInstancesInput) ([]ec2types.Instance, error)

	// DescribeInstanceAttribute returns the EC2 instance attribute on the given input
	// Returned values are commented in the interface doc comment block.
	DescribeInstanceAttribute(ctx context.Context, input *ec2.DescribeInstanceAttributeInput) (*ec2.DescribeInstanceAttributeOutput, error)

	// GetEC2InternetGateways returns the EC2 Internet Gateways on the given input
	// Returned values are commented in the interface doc comment block.
	GetEC2InternetGateways(ctx context.Context, input *ec2.DescribeInternetGatewaysInput) ([]ec2types.InternetGateway, error)

	// GetKeyPairs returns all KeyPairs based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetKeyPairs(ctx context.Context, input *ec2.DescribeKeyPairsInput) ([]ec2types.KeyPairInfo, error)

	// GetLaunchTemplates returns all LaunchTemplate belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetLaunchTemplates(ctx context.Context, input *ec2.DescribeLaunchTemplatesInput) ([]ec2types.LaunchTemplate, error)

	// GetEC2NatGateways returns the EC2 nat gateways on the given input
	// Returned values are commented in the interface doc comment block.
	GetEC2NatGateways(ctx context.Context, input *ec2.DescribeNatGatewaysInput) ([]ec2types.NatGateway, error)

	// GetSecurityGroups returns all EC2 security groups based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetSecurityGroups(ctx context.Context, input *ec2.DescribeSecurityGroupsInput) ([]ec2types.SecurityGroup, error)

	// GetSnapshots returns all snapshots based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) ([]ec2types.Snapshot, error)

	// GetOwnSnapshots returns all snapshots belonging to the Account ID based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetOwnSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) ([]ec2types.Snapshot, error)

	// GetSubnets returns all EC2 subnets based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetSubnets(ctx context.Context, input *ec2.DescribeSubnetsInput) ([]ec2types.Subnet, error)

	// GetVolumes returns all EC2 volumes based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetVolumes(ctx context.Context, input *ec2.DescribeVolumesInput) ([]ec2types.Volume, error)

	// GetVpcEndpoints returns the ec2 VPC Endpoints on the given input
	// Returned values are commented in the interface doc comment block.
	GetVpcEndpoints(ctx context.Context, input *ec2.DescribeVpcEndpointsInput) ([]ec2types.VpcEndpoint, error)

	// GetVpcs returns all EC2 VPCs based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetVpcs(ctx context.Context, input *ec2.DescribeVpcsInput) ([]ec2types.Vpc, error)

	// GetVpcPeeringConnections returns all VpcPeeringConnections based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetVpcPeeringConnections(ctx context.Context, input *ec2.DescribeVpcPeeringConnectionsInput) ([]ec2types.VpcPeeringConnection, error)

	// GetVPNGateways returns the ec2 VPN Gateways on the given input
	// Returned values are commented in the interface doc comment block.
	GetVPNGateways(ctx context.Context, input *ec2.DescribeVpnGatewaysInput) ([]ec2types.VpnGateway, error)

	// GetRouteTables returns the ec2 VPN Route Tables on the given input
	// Returned values are commented in the interface doc comment block.
	GetRouteTables(ctx context.Context, input *ec2.DescribeRouteTablesInput) ([]ec2types.RouteTable, error)

	// GetTransitGateways returns the ec2 Transit Gateways on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGateways(ctx context.Context, input *ec2.DescribeTransitGatewaysInput) ([]ec2types.TransitGateway, error)

	// GetTransitGateways returns the ec2 Transit Gateway VPC Attachments on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayVpcAttachments(ctx context.Context, input *ec2.DescribeTransitGatewayVpcAttachmentsInput) ([]ec2types.TransitGatewayVpcAttachment, error)

	// GetTransitGateways returns the ec2 Transit Gateway Route Tables on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayRouteTables(ctx context.Context, input *ec2.DescribeTransitGatewayRouteTablesInput) ([]ec2types.TransitGatewayRouteTable, error)

	// GetTransitGateways returns the ec2 Transit Gateway Multicasts on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayMulticast(ctx context.Context, input *ec2.DescribeTransitGatewayMulticastDomainsInput) ([]ec2types.TransitGatewayMulticastDomain, error)

	// GetTransitGatewayPeeringAttachments returns the ec2 Transit Gateway Peering Attachments on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayPeeringAttachments(ctx context.Context, input *ec2.DescribeTransitGatewayPeeringAttachmentsInput) ([]ec2types.TransitGatewayPeeringAttachment, error)

	// GetTransitGatewayPrefixListReference returns the ec2 Transit Gateway Prefix List References on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayPrefixListReference(ctx context.Context, input *ec2.GetTransitGatewayPrefixListReferencesInput) ([]ec2types.TransitGatewayPrefixListReference, error)

	// GetTransitGatewayRoutes returns the ec2 Transit Gateway Routes on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayRoutes(ctx context.Context, input *ec2.SearchTransitGatewayRoutesInput) ([]ec2types.TransitGatewayRoute, error)

	// GetTransitGatewayRouteTableAssociations returns the ec2 Transit Gateway Route Table Associations on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayRouteTableAssociations(ctx context.Context, input *ec2.GetTransitGatewayRouteTableAssociationsInput) ([]ec2types.TransitGatewayRouteTableAssociation, error)

	// GetTransitGatewayRouteTablePropagations returns the ec2 Transit Gateway Route Table Propagations on the given input
	// Returned values are commented in the interface doc comment block.
	GetTransitGatewayRouteTablePropagations(ctx context.Context, input *ec2.GetTransitGatewayRouteTablePropagationsInput) ([]ec2types.TransitGatewayRouteTablePropagation, error)

	// GetECSClustersArns returns the ecs clusters arns on the given input
	// Returned values are commented in the interface doc comment block.
	GetECSClustersArns(ctx context.Context, input *ecs.ListClustersInput) ([]string, error)

	// GetECSClusters returns the ecs clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetECSClusters(ctx context.Context, input *ecs.DescribeClustersInput) ([]ecstypes.Cluster, error)

	// GetECSServicesArns returns the ecs services arns on the given input
	// Returned values are commented in the interface doc comment block.
	GetECSServicesArns(ctx context.Context, input *ecs.ListServicesInput) ([]string, error)

	// GetECSServices returns the ecs services on the given input
	// Returned values are commented in the interface doc comment block.
	GetECSServices(ctx context.Context, input *ecs.DescribeServicesInput) ([]ecstypes.Service, error)

	// GetECSTaskDefinitionsArns returns the ecs task definitions arns on the given input
	// Returned values are commented in the interface doc comment block.
	GetECSTaskDefinitionsArns(ctx context.Context, input *ecs.ListTaskDefinitionsInput) ([]string, error)

	// GetEFSFileSystems returns the EFS File Systems on the given input
	// Returned values are commented in the interface doc comment block.
	GetEFSFileSystems(ctx context.Context, input *efs.DescribeFileSystemsInput) ([]efstypes.FileSystemDescription, error)

	// GetEKSCluster returns the EKS Cluster on the given input
	// Returned values are commented in the interface doc comment block.
	GetEKSCluster(ctx context.Context, input *eks.DescribeClusterInput) (*ekstypes.Cluster, error)

	// GetEKSClusters returns the EKS Clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetEKSClusters(ctx context.Context, input *eks.ListClustersInput) ([]string, error)

	// GetElastiCacheClusters returns all Elasticache clusters based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetElastiCacheClusters(ctx context.Context, input *elasticache.DescribeCacheClustersInput) ([]elasticachetypes.CacheCluster, error)

	// GetElastiCacheReplicationGroups returns the EKS Replication groups on the given input
	// Returned values are commented in the interface doc comment block.
	GetElastiCacheReplicationGroups(ctx context.Context, input *elasticache.DescribeReplicationGroupsInput) ([]elasticachetypes.ReplicationGroup, error)

	// GetElastiCacheTags returns a list of tags of Elasticache resources based on its ARN.
	// Returned values are commented in the interface doc comment block.
	GetElastiCacheTags(ctx context.Context, input *elasticache.ListTagsForResourceInput) ([]elasticachetypes.Tag, error)

	// GetElasticBeanstalkApplications returns the ElasticBeanstalk Applications on the given input
	// Returned values are commented in the interface doc comment block.
	GetElasticBeanstalkApplications(ctx context.Context, input *elasticbeanstalk.DescribeApplicationsInput) ([]elasticbeanstalktypes.ApplicationDescription, error)

	// GetElasticsearchDomainNames returns a list of domainNames of Elasticsearch resources.
	// Returned values are commented in the interface doc comment block.
	GetElasticsearchDomainNames(ctx context.Context, input *elasticsearchservice.ListDomainNamesInput) ([]elasticsearchservicetypes.DomainInfo, error)

	// GetElasticsearchDomains returns a list of domains of Elasticsearch resources.
	// Returned values are commented in the interface doc comment block.
	GetElasticsearchDomains(ctx context.Context, input *elasticsearchservice.DescribeElasticsearchDomainsInput) ([]elasticsearchservicetypes.ElasticsearchDomainStatus, error)

	// GetLoadBalancerAttributes returns a list of Attributes based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancerAttributes(ctx context.Context, input *elasticloadbalancing.DescribeLoadBalancerAttributesInput) ([]elasticloadbalancingtypes.AdditionalAttribute, error)

	// GetLoadBalancers returns a list of ELB (v1) based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancers(ctx context.Context, input *elasticloadbalancing.DescribeLoadBalancersInput) ([]elasticloadbalancingtypes.LoadBalancerDescription, error)

	// GetLoadBalancerPolicies returns a list of Policies based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancerPolicies(ctx context.Context, input *elasticloadbalancing.DescribeLoadBalancerPoliciesInput) ([]elasticloadbalancingtypes.PolicyDescription, error)

	// GetLoadBalancersTags returns a list of Tags based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersTags(ctx context.Context, input *elasticloadbalancing.DescribeTagsInput) ([]elasticloadbalancingtypes.TagDescription, error)

	// GetListenerCertificates returns a list of ListenerCertificates based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetListenerCertificates(ctx context.Context, input *elasticloadbalancingv2.DescribeListenerCertificatesInput) ([]elasticloadbalancingv2types.Certificate, error)

	// GetLoadBalancersV2Listeners returns a list of Listeners based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2Listeners(ctx context.Context, input *elasticloadbalancingv2.DescribeListenersInput) ([]elasticloadbalancingv2types.Listener, error)

	// GetLoadBalancersV2 returns a list of ELB (v2) - also known as ALB - based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2(ctx context.Context, input *elasticloadbalancingv2.DescribeLoadBalancersInput) ([]elasticloadbalancingv2types.LoadBalancer, error)

	// GetLoadBalancersV2Tags returns a list of Tags based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2Tags(ctx context.Context, input *elasticloadbalancingv2.DescribeTagsInput) ([]elasticloadbalancingv2types.TagDescription, error)

	// GetLoadBalancersV2TargetGroupAttributes returns a list of TargetGroupAttributes based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2TargetGroupAttributes(ctx context.Context, input *elasticloadbalancingv2.DescribeTargetGroupAttributesInput) ([]elasticloadbalancingv2types.TargetGroupAttribute, error)

	// GetLoadBalancersV2TargetGroups returns a list of TargetGroups based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2TargetGroups(ctx context.Context, input *elasticloadbalancingv2.DescribeTargetGroupsInput) ([]elasticloadbalancingv2types.TargetGroup, error)

	// GetLoadBalancersV2TargetHealth returns a list of TargetHealth based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2TargetHealth(ctx context.Context, input *elasticloadbalancingv2.DescribeTargetHealthInput) ([]elasticloadbalancingv2types.TargetHealthDescription, error)

	// GetLoadBalancersV2Rules returns a list of Rules based on the input from the different regions.
	// Returned values are commented in the interface doc comment block.
	GetLoadBalancersV2Rules(ctx context.Context, input *elasticloadbalancingv2.DescribeRulesInput) ([]elasticloadbalancingv2types.Rule, error)

	// GetEMRClusters returns the EMR Clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetEMRClusters(ctx context.Context, input *emr.ListClustersInput) ([]emrtypes.ClusterSummary, error)

	// GetFSXFileSystems returns the fsx filesystems arns on the given input
	// Returned values are commented in the interface doc comment block.
	GetFSXFileSystems(ctx context.Context, input *fsx.DescribeFileSystemsInput) ([]fsxtypes.FileSystem, error)

	// GetGlueDatabases returns the Glue databases on the given input
	// Returned values are commented in the interface doc comment block.
	GetGlueDatabases(ctx context.Context, input *glue.GetDatabasesInput) ([]gluetypes.Database, error)

	// GetGlueTables returns the Glue Tables on the given input
	// Returned values are commented in the interface doc comment block.
	GetGlueTables(ctx context.Context, input *glue.GetTablesInput) ([]gluetypes.Table, error)

	// GetAccessKeys returns all the IAM AccessKeys on the given input
	// Returned values are commented in the interface doc comment block.
	GetAccessKeys(ctx context.Context, input *iam.ListAccessKeysInput) ([]iamtypes.AccessKeyMetadata, error)

	// GetAccountAliases returns all the IAM AccountAliases on the given input
	// Returned values are commented in the interface doc comment block.
	GetAccountAliases(ctx context.Context, input *iam.ListAccountAliasesInput) ([]string, error)

	// GetAccountPasswordPolicy returns the IAM AccountPasswordPolicy on the given input
	// Returned values are commented in the interface doc comment block.
	GetAccountPasswordPolicy(ctx context.Context, input *iam.GetAccountPasswordPolicyInput) (*iamtypes.PasswordPolicy, error)

	// GetAttachedGroupPolicies returns the IAM AttachedGroupPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetAttachedGroupPolicies(ctx context.Context, input *iam.ListAttachedGroupPoliciesInput) ([]iamtypes.AttachedPolicy, error)

	// GetAttachedRolePolicies returns the IAM AttachedRolePolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetAttachedRolePolicies(ctx context.Context, input *iam.ListAttachedRolePoliciesInput) ([]iamtypes.AttachedPolicy, error)

	// GetAttachedUserPolicies returns the IAM AttachedUserPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetAttachedUserPolicies(ctx context.Context, input *iam.ListAttachedUserPoliciesInput) ([]iamtypes.AttachedPolicy, error)

	// GetGroupUsers returns a list of IAM users that are in the specified IAM group
	// Returned values are commented in the interface doc comment block.
	GetGroupUsers(ctx context.Context, input *iam.GetGroupInput) ([]iamtypes.User, error)

	// GetGroupPolicies returns the IAM GroupPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetGroupPolicies(ctx context.Context, input *iam.ListGroupPoliciesInput) ([]string, error)

	// GetGroups returns the IAM Groups on the given input
	// Returned values are commented in the interface doc comment block.
	GetGroups(ctx context.Context, input *iam.ListGroupsInput) ([]iamtypes.Group, error)

	// GetGroupsForUser returns the IAM GroupsForUser on the given input
	// Returned values are commented in the interface doc comment block.
	GetGroupsForUser(ctx context.Context, input *iam.ListGroupsForUserInput) ([]iamtypes.Group, error)

	// GetIstanceProfiles returns the IAM InstanceProfiles on the given input
	// Returned values are commented in the interface doc comment block.
	GetInstanceProfiles(ctx context.Context, input *iam.ListInstanceProfilesInput) ([]iamtypes.InstanceProfile, error)

	// GetOpenIDConnectProviders returns the IAM OpenIDConnectProviders on the given input
	// Returned values are commented in the interface doc comment block.
	GetOpenIDConnectProviders(ctx context.Context, input *iam.ListOpenIDConnectProvidersInput) ([]iamtypes.OpenIDConnectProviderListEntry, error)

	// GetPolicies returns the IAM Policies on the given input
	// Returned values are commented in the interface doc comment block.
	GetPolicies(ctx context.Context, input *iam.ListPoliciesInput) ([]iamtypes.Policy, error)

	// GetRolePolicies returns the IAM RolePolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetRolePolicies(ctx context.Context, input *iam.ListRolePoliciesInput) ([]string, error)

	// GetRoles returns the IAM Roles on the given input
	// Returned values are commented in the interface doc comment block.
	GetRoles(ctx context.Context, input *iam.ListRolesInput) ([]iamtypes.Role, error)

	// GetSAMLProviders returns the IAM SAMLProviders on the given input
	// Returned values are commented in the interface doc comment block.
	GetSAMLProviders(ctx context.Context, input *iam.ListSAMLProvidersInput) ([]iamtypes.SAMLProviderListEntry, error)

	// GetServerCertificates returns the IAM ServerCertificates on the given input
	// Returned values are commented in the interface doc comment block.
	GetServerCertificates(ctx context.Context, input *iam.ListServerCertificatesInput) ([]iamtypes.ServerCertificateMetadata, error)

	// GetSSHPublicKeys returns the IAM SSHPublicKeys on the given input
	// Returned values are commented in the interface doc comment block.
	GetSSHPublicKeys(ctx context.Context, input *iam.ListSSHPublicKeysInput) ([]iamtypes.SSHPublicKeyMetadata, error)

	// GetUserPolicies returns the IAM UserPolicies on the given input
	// Returned values are commented in the interface doc comment block.
	GetUserPolicies(ctx context.Context, input *iam.ListUserPoliciesInput) ([]string, error)

	// GetUsers returns the IAM Users on the given input
	// Returned values are commented in the interface doc comment block.
	GetUsers(ctx context.Context, input *iam.ListUsersInput) ([]iamtypes.User, error)

	// GetKinesisStreams returns the Kinesis Streams on the given input
	// Returned values are commented in the interface doc comment block.
	GetKinesisStreams(ctx context.Context, input *kinesis.ListStreamsInput) ([]string, error)

	// GetLambdaFunctions returns the lambda Functions on the given input
	// Returned values are commented in the interface doc comment block.
	GetLambdaFunctions(ctx context.Context, input *lambda.ListFunctionsInput) ([]lambdatypes.FunctionConfiguration, error)

	// GetLightsailInstances returns the Lightsail Instances on the given input
	// Returned values are commented in the interface doc comment block.
	GetLightsailInstances(ctx context.Context, input *lightsail.GetInstancesInput) ([]lightsailtypes.Instance, error)

	// GetMediastoreContainers returns the Mediastore Containers on the given input
	// Returned values are commented in the interface doc comment block.
	GetMediastoreContainers(ctx context.Context, input *mediastore.ListContainersInput) ([]mediastoretypes.Container, error)

	// GetMQBrokers returns the MQ Brokers on the given input
	// Returned values are commented in the interface doc comment block.
	GetMQBrokers(ctx context.Context, input *mq.ListBrokersInput) ([]mqtypes.BrokerSummary, error)

	// GetNeptuneDBClusters returns the Neptune DBClusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetNeptuneDBClusters(ctx context.Context, input *neptune.DescribeDBClustersInput) ([]neptunetypes.DBCluster, error)

	// GetRDSDBClusters returns the RDS DB Clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetRDSDBClusters(ctx context.Context, input *rds.DescribeDBClustersInput) ([]rdstypes.DBCluster, error)

	// GetDBInstances returns all DB instances based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetDBInstances(ctx context.Context, input *rds.DescribeDBInstancesInput) ([]rdstypes.DBInstance, error)

	// GetDBParameterGroups returns all DB parameterGroups based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetDBParameterGroups(ctx context.Context, input *rds.DescribeDBParameterGroupsInput) ([]rdstypes.DBParameterGroup, error)

	// GetDBSubnetGroups returns all DB DBSubnetGroups based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetDBSubnetGroups(ctx context.Context, input *rds.DescribeDBSubnetGroupsInput) ([]rdstypes.DBSubnetGroup, error)

	// GetRDSGlobalClusters returns the RDS Global Clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetRDSGlobalClusters(ctx context.Context, input *rds.DescribeGlobalClustersInput) ([]rdstypes.GlobalCluster, error)

	// GetDBInstancesTags returns a list of tags from an ARN, extra filters for tags can also be provided.
	// Returned values are commented in the interface doc comment block.
	GetDBInstancesTags(ctx context.Context, input *rds.ListTagsForResourceInput) ([]rdstypes.Tag, error)

	// GetRedshiftClusters returns the Redshift Clusters on the given input
	// Returned values are commented in the interface doc comment block.
	GetRedshiftClusters(ctx context.Context, input *redshift.DescribeClustersInput) ([]redshifttypes.Cluster, error)

	// GetQueryLoggingConfigs returns the Route53 QueryLoggingConfigs on the given input
	// Returned values are commented in the interface doc comment block.
	GetQueryLoggingConfigs(ctx context.Context, input *route53.ListQueryLoggingConfigsInput) ([]route53types.QueryLoggingConfig, error)

	// GetHealthChecks returns the Route53 HealthChecks on the given input
	// Returned values are commented in the interface doc comment block.
	GetHealthChecks(ctx context.Context, input *route53.ListHealthChecksInput) ([]route53types.HealthCheck, error)

	// GetHostedZones returns the Route53 HostedZones on the given input
	// Returned values are commented in the interface doc comment block.
	GetHostedZones(ctx context.Context, input *route53.ListHostedZonesInput) ([]route53types.HostedZone, error)

	// GetResourceRecordSets returns the Route53 ResourceRecordSets on the given input
	// Returned values are commented in the interface doc comment block.
	GetResourceRecordSets(ctx context.Context, input *route53.ListResourceRecordSetsInput) ([]route53types.ResourceRecordSet, error)

	// GetReusableDelegationSets returns the Route53 ReusableDelegationSets on the given input
	// Returned values are commented in the interface doc comment block.
	GetReusableDelegationSets(ctx context.Context, input *route53.ListReusableDelegationSetsInput) ([]route53types.DelegationSet, error)

	// GetVPCAssociationAuthorizations returns the Route53 VPCAssociationAuthorizations on the given input
	// Returned values are commented in the interface doc comment block.
	GetVPCAssociationAuthorizations(ctx context.Context, input *route53.ListVPCAssociationAuthorizationsInput) ([]route53types.VPC, error)

	// GetResolverEndpoints returns the Route53Resolver ResolverEndpoints on the given input
	// Returned values are commented in the interface doc comment block.
	GetResolverEndpoints(ctx context.Context, input *route53resolver.ListResolverEndpointsInput) ([]route53resolvertypes.ResolverEndpoint, error)

	// GetResolverRuleAssociations returns the Route53Resolver ResolverRuleAssociations on the given input
	// Returned values are commented in the interface doc comment block.
	GetResolverRuleAssociations(ctx context.Context, input *route53resolver.ListResolverRuleAssociationsInput) ([]route53resolvertypes.ResolverRuleAssociation, error)

	// GetResolverRules returns the Route53Resolver ResolverRules on the given input
	// Returned values are commented in the interface doc comment block.
	GetResolverRules(ctx context.Context, input *route53resolver.ListResolverRulesInput) ([]route53resolvertypes.ResolverRule, error)

	// ListBuckets returns all S3 buckets based on the input given and specifically
	// filtering by Location as ListBuckets does not do it by itself
	// Returned values are commented in the interface doc comment block.
	ListBuckets(ctx context.Context, input *s3.ListBucketsInput) ([]s3types.Bucket, error)

	// GetBucketTags returns tags associated with S3 buckets based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetBucketTags(ctx context.Context, input *s3.GetBucketTaggingInput) ([]s3types.Tag, error)

	// ListObjects returns a list of all S3 objects in a bucket based on the input given.
	// Returned values are commented in the interface doc comment block.
	ListObjects(ctx context.Context, input *s3.ListObjectsInput) ([]s3types.Object, error)

	// GetObjectsTags returns tags associated with S3 objects based on the input given.
	// Returned values are commented in the interface doc comment block.
	GetObjectsTags(ctx context.Context, input *s3.GetObjectTaggingInput) ([]s3types.Tag, error)

	// GetActiveReceiptRuleSet returns the SES ActiveReceiptRuleSet on the given input
	// Returned values are commented in the interface doc comment block.
	GetActiveReceiptRuleSet(ctx context.Context, input *ses.DescribeActiveReceiptRuleSetInput) (*string, error)

	// GetActiveReceiptRulesSet returns the SES ActiveReceiptRuleSet on the given input
	// Returned values are commented in the interface doc comment block.
	GetActiveReceiptRulesSet(ctx context.Context, input *ses.DescribeActiveReceiptRuleSetInput) ([]sestypes.ReceiptRule, error)

	// GetConfigurationSets returns the SES ConfigurationSets on the given input
	// Returned values are commented in the interface doc comment block.
	GetConfigurationSets(ctx context.Context, input *ses.ListConfigurationSetsInput) ([]sestypes.ConfigurationSet, error)

	// GetIdentities returns the SES Identities on the given input
	// Returned values are commented in the interface doc comment block.
	GetIdentities(ctx context.Context, input *ses.ListIdentitiesInput) ([]string, error)

	// GetIdentityNotificationAttributes returns the SES IdentityNotificationAttributes on the given input
	// Returned values are commented in the interface doc comment block.
	GetIdentityNotificationAttributes(ctx context.Context, input *ses.GetIdentityNotificationAttributesInput) (map[string]sestypes.IdentityNotificationAttributes, error)

	// GetReceiptFilters returns the SES ReceiptFilters on the given input
	// Returned values are commented in the interface doc comment block.
	GetReceiptFilters(ctx context.Context, input *ses.ListReceiptFiltersInput) ([]sestypes.ReceiptFilter, error)

	// GetTemplates returns the SES Templates on the given input
	// Returned values are commented in the interface doc comment block.
	GetTemplates(ctx context.Context, input *ses.ListTemplatesInput) ([]sestypes.TemplateMetadata, error)

	// GetSQSQueues returns the SQS Queues on the given input
	// Returned values are commented in the interface doc comment block.
	GetSQSQueues(ctx context.Context, input *sqs.ListQueuesInput) ([]string, error)

	// GetStorageGatewayGateways returns the StorageGateway Gateways on the given input
	// Returned values are commented in the interface doc comment block.
	GetStorageGatewayGateways(ctx context.Context, input *storagegateway.ListGatewaysInput) ([]storagegatewaytypes.GatewayInfo, error)
}

func (c *connector) GetAPIGatewayDeployments(ctx context.Context, input *apigateway.GetDeploymentsInput) ([]apigatewaytypes.Deployment, error) {
	if c.svc.apigateway == nil {
		c.svc.apigateway = apigateway.NewFromConfig(c.svc.config)
	}

	opt := make([]apigatewaytypes.Deployment, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.apigateway.GetDeployments(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Items == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &apigateway.GetDeploymentsInput{}
		}
		input.Position = o.Position
		hasNextToken = o.Position != nil

		opt = append(opt, o.Items...)

	}

	return opt, nil
}

func (c *connector) GetAPIGatewayResources(ctx context.Context, input *apigateway.GetResourcesInput) ([]apigatewaytypes.Resource, error) {
	if c.svc.apigateway == nil {
		c.svc.apigateway = apigateway.NewFromConfig(c.svc.config)
	}

	opt := make([]apigatewaytypes.Resource, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.apigateway.GetResources(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Items == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &apigateway.GetResourcesInput{}
		}
		input.Position = o.Position
		hasNextToken = o.Position != nil

		opt = append(opt, o.Items...)

	}

	return opt, nil
}

func (c *connector) GetAPIGatewayRestAPIs(ctx context.Context, input *apigateway.GetRestApisInput) ([]apigatewaytypes.RestApi, error) {
	if c.svc.apigateway == nil {
		c.svc.apigateway = apigateway.NewFromConfig(c.svc.config)
	}

	opt := make([]apigatewaytypes.RestApi, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.apigateway.GetRestApis(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Items == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &apigateway.GetRestApisInput{}
		}
		input.Position = o.Position
		hasNextToken = o.Position != nil

		opt = append(opt, o.Items...)

	}

	return opt, nil
}

func (c *connector) GetAPIGatewayStages(ctx context.Context, input *apigateway.GetStagesInput) ([]apigatewaytypes.Stage, error) {
	if c.svc.apigateway == nil {
		c.svc.apigateway = apigateway.NewFromConfig(c.svc.config)
	}

	opt := make([]apigatewaytypes.Stage, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.apigateway.GetStages(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Item == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Item...)

	}

	return opt, nil
}

func (c *connector) GetAthenaWorkGroups(ctx context.Context, input *athena.ListWorkGroupsInput) ([]athenatypes.WorkGroupSummary, error) {
	if c.svc.athena == nil {
		c.svc.athena = athena.NewFromConfig(c.svc.config)
	}

	opt := make([]athenatypes.WorkGroupSummary, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.athena.ListWorkGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.WorkGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &athena.ListWorkGroupsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.WorkGroups...)

	}

	return opt, nil
}

func (c *connector) GetAutoScalingGroups(ctx context.Context, input *autoscaling.DescribeAutoScalingGroupsInput) ([]autoscalingtypes.AutoScalingGroup, error) {
	if c.svc.autoscaling == nil {
		c.svc.autoscaling = autoscaling.NewFromConfig(c.svc.config)
	}

	opt := make([]autoscalingtypes.AutoScalingGroup, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.autoscaling.DescribeAutoScalingGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.AutoScalingGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &autoscaling.DescribeAutoScalingGroupsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.AutoScalingGroups...)

	}

	return opt, nil
}

func (c *connector) GetLaunchConfigurations(ctx context.Context, input *autoscaling.DescribeLaunchConfigurationsInput) ([]autoscalingtypes.LaunchConfiguration, error) {
	if c.svc.autoscaling == nil {
		c.svc.autoscaling = autoscaling.NewFromConfig(c.svc.config)
	}

	opt := make([]autoscalingtypes.LaunchConfiguration, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.autoscaling.DescribeLaunchConfigurations(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.LaunchConfigurations == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &autoscaling.DescribeLaunchConfigurationsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.LaunchConfigurations...)

	}

	return opt, nil
}

func (c *connector) GetAutoScalingPolicies(ctx context.Context, input *autoscaling.DescribePoliciesInput) ([]autoscalingtypes.ScalingPolicy, error) {
	if c.svc.autoscaling == nil {
		c.svc.autoscaling = autoscaling.NewFromConfig(c.svc.config)
	}

	opt := make([]autoscalingtypes.ScalingPolicy, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.autoscaling.DescribePolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ScalingPolicies == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &autoscaling.DescribePoliciesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ScalingPolicies...)

	}

	return opt, nil
}

func (c *connector) GetAutoScalingScheduledActions(ctx context.Context, input *autoscaling.DescribeScheduledActionsInput) ([]autoscalingtypes.ScheduledUpdateGroupAction, error) {
	if c.svc.autoscaling == nil {
		c.svc.autoscaling = autoscaling.NewFromConfig(c.svc.config)
	}

	opt := make([]autoscalingtypes.ScheduledUpdateGroupAction, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.autoscaling.DescribeScheduledActions(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ScheduledUpdateGroupActions == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &autoscaling.DescribeScheduledActionsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ScheduledUpdateGroupActions...)

	}

	return opt, nil
}

func (c *connector) GetBatchJobDefinitions(ctx context.Context, input *batch.DescribeJobDefinitionsInput) ([]batchtypes.JobDefinition, error) {
	if c.svc.batch == nil {
		c.svc.batch = batch.NewFromConfig(c.svc.config)
	}

	opt := make([]batchtypes.JobDefinition, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.batch.DescribeJobDefinitions(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.JobDefinitions == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &batch.DescribeJobDefinitionsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.JobDefinitions...)

	}

	return opt, nil
}

func (c *connector) GetCloudFrontDistributions(ctx context.Context, input *cloudfront.ListDistributionsInput) ([]cloudfronttypes.DistributionSummary, error) {
	if c.svc.cloudfront == nil {
		c.svc.cloudfront = cloudfront.NewFromConfig(c.svc.config)
	}

	opt := make([]cloudfronttypes.DistributionSummary, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.cloudfront.ListDistributions(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DistributionList == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &cloudfront.ListDistributionsInput{}
		}
		input.Marker = o.DistributionList.NextMarker
		hasNextToken = o.DistributionList.NextMarker != nil

		opt = append(opt, o.DistributionList.Items...)

	}

	return opt, nil
}

func (c *connector) GetCloudFrontOriginAccessIdentities(ctx context.Context, input *cloudfront.ListCloudFrontOriginAccessIdentitiesInput) ([]cloudfronttypes.CloudFrontOriginAccessIdentitySummary, error) {
	if c.svc.cloudfront == nil {
		c.svc.cloudfront = cloudfront.NewFromConfig(c.svc.config)
	}

	opt := make([]cloudfronttypes.CloudFrontOriginAccessIdentitySummary, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.cloudfront.ListCloudFrontOriginAccessIdentities(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.CloudFrontOriginAccessIdentityList == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &cloudfront.ListCloudFrontOriginAccessIdentitiesInput{}
		}
		input.Marker = o.CloudFrontOriginAccessIdentityList.NextMarker
		hasNextToken = o.CloudFrontOriginAccessIdentityList.NextMarker != nil

		opt = append(opt, o.CloudFrontOriginAccessIdentityList.Items...)

	}

	return opt, nil
}

func (c *connector) GetCloudFrontPublicKeys(ctx context.Context, input *cloudfront.ListPublicKeysInput) ([]cloudfronttypes.PublicKeySummary, error) {
	if c.svc.cloudfront == nil {
		c.svc.cloudfront = cloudfront.NewFromConfig(c.svc.config)
	}

	opt := make([]cloudfronttypes.PublicKeySummary, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.cloudfront.ListPublicKeys(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.PublicKeyList == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &cloudfront.ListPublicKeysInput{}
		}
		input.Marker = o.PublicKeyList.NextMarker
		hasNextToken = o.PublicKeyList.NextMarker != nil

		opt = append(opt, o.PublicKeyList.Items...)

	}

	return opt, nil
}

func (c *connector) GetMetricAlarms(ctx context.Context, input *cloudwatch.DescribeAlarmsInput) ([]cloudwatchtypes.MetricAlarm, error) {
	if c.svc.cloudwatch == nil {
		c.svc.cloudwatch = cloudwatch.NewFromConfig(c.svc.config)
	}

	opt := make([]cloudwatchtypes.MetricAlarm, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.cloudwatch.DescribeAlarms(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.MetricAlarms == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &cloudwatch.DescribeAlarmsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.MetricAlarms...)

	}

	return opt, nil
}

func (c *connector) GetRecordedResourceCounts(ctx context.Context, input *configservice.GetDiscoveredResourceCountsInput) ([]configservicetypes.ResourceCount, error) {
	if c.svc.configservice == nil {
		c.svc.configservice = configservice.NewFromConfig(c.svc.config)
	}

	opt := make([]configservicetypes.ResourceCount, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.configservice.GetDiscoveredResourceCounts(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ResourceCounts == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &configservice.GetDiscoveredResourceCountsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ResourceCounts...)

	}

	return opt, nil
}

func (c *connector) GetDAXClusters(ctx context.Context, input *dax.DescribeClustersInput) ([]daxtypes.Cluster, error) {
	if c.svc.dax == nil {
		c.svc.dax = dax.NewFromConfig(c.svc.config)
	}

	opt := make([]daxtypes.Cluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.dax.DescribeClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Clusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &dax.DescribeClustersInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Clusters...)

	}

	return opt, nil
}

func (c *connector) GetDirectConnectGateways(ctx context.Context, input *directconnect.DescribeDirectConnectGatewaysInput) ([]directconnecttypes.DirectConnectGateway, error) {
	if c.svc.directconnect == nil {
		c.svc.directconnect = directconnect.NewFromConfig(c.svc.config)
	}

	opt := make([]directconnecttypes.DirectConnectGateway, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.directconnect.DescribeDirectConnectGateways(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DirectConnectGateways == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &directconnect.DescribeDirectConnectGatewaysInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.DirectConnectGateways...)

	}

	return opt, nil
}

func (c *connector) GetDirectoryServiceDirectories(ctx context.Context, input *directoryservice.DescribeDirectoriesInput) ([]directoryservicetypes.DirectoryDescription, error) {
	if c.svc.directoryservice == nil {
		c.svc.directoryservice = directoryservice.NewFromConfig(c.svc.config)
	}

	opt := make([]directoryservicetypes.DirectoryDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.directoryservice.DescribeDirectories(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DirectoryDescriptions == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &directoryservice.DescribeDirectoriesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.DirectoryDescriptions...)

	}

	return opt, nil
}

func (c *connector) GetDMSDescribeReplicationInstances(ctx context.Context, input *databasemigrationservice.DescribeReplicationInstancesInput) ([]databasemigrationservicetypes.ReplicationInstance, error) {
	if c.svc.databasemigrationservice == nil {
		c.svc.databasemigrationservice = databasemigrationservice.NewFromConfig(c.svc.config)
	}

	opt := make([]databasemigrationservicetypes.ReplicationInstance, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.databasemigrationservice.DescribeReplicationInstances(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ReplicationInstances == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &databasemigrationservice.DescribeReplicationInstancesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.ReplicationInstances...)

	}

	return opt, nil
}

func (c *connector) GetDynamodbGlobalTables(ctx context.Context, input *dynamodb.ListGlobalTablesInput) ([]dynamodbtypes.GlobalTable, error) {
	if c.svc.dynamodb == nil {
		c.svc.dynamodb = dynamodb.NewFromConfig(c.svc.config)
	}

	opt := make([]dynamodbtypes.GlobalTable, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.dynamodb.ListGlobalTables(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.GlobalTables == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &dynamodb.ListGlobalTablesInput{}
		}
		input.ExclusiveStartGlobalTableName = o.LastEvaluatedGlobalTableName
		hasNextToken = o.LastEvaluatedGlobalTableName != nil

		opt = append(opt, o.GlobalTables...)

	}

	return opt, nil
}

func (c *connector) GetDynamodbTables(ctx context.Context, input *dynamodb.ListTablesInput) ([]string, error) {
	if c.svc.dynamodb == nil {
		c.svc.dynamodb = dynamodb.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.dynamodb.ListTables(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TableNames == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &dynamodb.ListTablesInput{}
		}
		input.ExclusiveStartTableName = o.LastEvaluatedTableName
		hasNextToken = o.LastEvaluatedTableName != nil

		opt = append(opt, o.TableNames...)

	}

	return opt, nil
}

func (c *connector) GetAddresses(ctx context.Context, input *ec2.DescribeAddressesInput) ([]ec2types.Address, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Address, 0)

hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeAddresses(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Addresses == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Addresses...)

	}

	return opt, nil
}

func (c *connector) GetImages(ctx context.Context, input *ec2.DescribeImagesInput) ([]ec2types.Image, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Image, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeImages(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Images == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Images...)

	}

	return opt, nil
}

func (c *connector) GetOwnImages(ctx context.Context, input *ec2.DescribeImagesInput) ([]ec2types.Image, error) {

	if input == nil {
		input = &ec2.DescribeImagesInput{}
	}
	input.Owners = append(input.Owners, c.accountID)
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Image, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeImages(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Images == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Images...)

	}

	return opt, nil
}

func (c *connector) DescribeInstanceAttribute(ctx context.Context, input *ec2.DescribeInstanceAttributeInput) (*ec2.DescribeInstanceAttributeOutput, error){
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	return c.svc.ec2.DescribeInstanceAttribute(ctx, input)
}

func (c *connector) GetInstances(ctx context.Context, input *ec2.DescribeInstancesInput) ([]ec2types.Instance, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Instance, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeInstances(ctx, input)
		if err != nil {
			return nil, err
		}
		
		if o.Reservations == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeInstancesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		for _, v := range o.Reservations {
			opt = append(opt, v.Instances...)
		}

	}

	return opt, nil
}

func (c *connector) GetEC2InternetGateways(ctx context.Context, input *ec2.DescribeInternetGatewaysInput) ([]ec2types.InternetGateway, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.InternetGateway, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeInternetGateways(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.InternetGateways == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeInternetGatewaysInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.InternetGateways...)

	}

	return opt, nil
}

func (c *connector) GetKeyPairs(ctx context.Context, input *ec2.DescribeKeyPairsInput) ([]ec2types.KeyPairInfo, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.KeyPairInfo, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeKeyPairs(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.KeyPairs == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.KeyPairs...)

	}

	return opt, nil
}

func (c *connector) GetLaunchTemplates(ctx context.Context, input *ec2.DescribeLaunchTemplatesInput) ([]ec2types.LaunchTemplate, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.LaunchTemplate, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeLaunchTemplates(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.LaunchTemplates == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeLaunchTemplatesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.LaunchTemplates...)

	}

	return opt, nil
}

func (c *connector) GetEC2NatGateways(ctx context.Context, input *ec2.DescribeNatGatewaysInput) ([]ec2types.NatGateway, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.NatGateway, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeNatGateways(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.NatGateways == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeNatGatewaysInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.NatGateways...)

	}

	return opt, nil
}

func (c *connector) GetSecurityGroups(ctx context.Context, input *ec2.DescribeSecurityGroupsInput) ([]ec2types.SecurityGroup, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.SecurityGroup, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeSecurityGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.SecurityGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeSecurityGroupsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.SecurityGroups...)

	}

	return opt, nil
}

func (c *connector) GetSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) ([]ec2types.Snapshot, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Snapshot, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeSnapshots(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Snapshots == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeSnapshotsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Snapshots...)

	}

	return opt, nil
}

func (c *connector) GetOwnSnapshots(ctx context.Context, input *ec2.DescribeSnapshotsInput) ([]ec2types.Snapshot, error) {

	if input == nil {
		input = &ec2.DescribeSnapshotsInput{}
	}
	input.OwnerIds = append(input.OwnerIds, c.accountID)
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Snapshot, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeSnapshots(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Snapshots == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeSnapshotsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Snapshots...)

	}

	return opt, nil
}

func (c *connector) GetSubnets(ctx context.Context, input *ec2.DescribeSubnetsInput) ([]ec2types.Subnet, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Subnet, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeSubnets(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Subnets == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeSubnetsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Subnets...)

	}

	return opt, nil
}

func (c *connector) GetVolumes(ctx context.Context, input *ec2.DescribeVolumesInput) ([]ec2types.Volume, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Volume, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeVolumes(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Volumes == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeVolumesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Volumes...)

	}

	return opt, nil
}

func (c *connector) GetVpcEndpoints(ctx context.Context, input *ec2.DescribeVpcEndpointsInput) ([]ec2types.VpcEndpoint, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.VpcEndpoint, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeVpcEndpoints(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.VpcEndpoints == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeVpcEndpointsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.VpcEndpoints...)

	}

	return opt, nil
}

func (c *connector) GetVpcs(ctx context.Context, input *ec2.DescribeVpcsInput) ([]ec2types.Vpc, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.Vpc, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeVpcs(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Vpcs == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeVpcsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Vpcs...)

	}

	return opt, nil
}

func (c *connector) GetVpcPeeringConnections(ctx context.Context, input *ec2.DescribeVpcPeeringConnectionsInput) ([]ec2types.VpcPeeringConnection, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.VpcPeeringConnection, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeVpcPeeringConnections(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.VpcPeeringConnections == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeVpcPeeringConnectionsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.VpcPeeringConnections...)

	}

	return opt, nil
}

func (c *connector) GetVPNGateways(ctx context.Context, input *ec2.DescribeVpnGatewaysInput) ([]ec2types.VpnGateway, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.VpnGateway, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeVpnGateways(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.VpnGateways == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.VpnGateways...)

	}

	return opt, nil
}

func (c *connector) GetRouteTables(ctx context.Context, input *ec2.DescribeRouteTablesInput) ([]ec2types.RouteTable, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.RouteTable, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeRouteTables(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.RouteTables == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.RouteTables...)

	}

	return opt, nil
}

func (c *connector) GetTransitGateways(ctx context.Context, input *ec2.DescribeTransitGatewaysInput) ([]ec2types.TransitGateway, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGateway, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeTransitGateways(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGateways == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeTransitGatewaysInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGateways...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayVpcAttachments(ctx context.Context, input *ec2.DescribeTransitGatewayVpcAttachmentsInput) ([]ec2types.TransitGatewayVpcAttachment, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayVpcAttachment, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeTransitGatewayVpcAttachments(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGatewayVpcAttachments == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeTransitGatewayVpcAttachmentsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGatewayVpcAttachments...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayRouteTables(ctx context.Context, input *ec2.DescribeTransitGatewayRouteTablesInput) ([]ec2types.TransitGatewayRouteTable, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayRouteTable, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeTransitGatewayRouteTables(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGatewayRouteTables == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeTransitGatewayRouteTablesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGatewayRouteTables...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayMulticast(ctx context.Context, input *ec2.DescribeTransitGatewayMulticastDomainsInput) ([]ec2types.TransitGatewayMulticastDomain, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayMulticastDomain, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeTransitGatewayMulticastDomains(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGatewayMulticastDomains == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeTransitGatewayMulticastDomainsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGatewayMulticastDomains...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayPeeringAttachments(ctx context.Context, input *ec2.DescribeTransitGatewayPeeringAttachmentsInput) ([]ec2types.TransitGatewayPeeringAttachment, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayPeeringAttachment, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.DescribeTransitGatewayPeeringAttachments(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGatewayPeeringAttachments == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.DescribeTransitGatewayPeeringAttachmentsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGatewayPeeringAttachments...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayPrefixListReference(ctx context.Context, input *ec2.GetTransitGatewayPrefixListReferencesInput) ([]ec2types.TransitGatewayPrefixListReference, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayPrefixListReference, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.GetTransitGatewayPrefixListReferences(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGatewayPrefixListReferences == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.GetTransitGatewayPrefixListReferencesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGatewayPrefixListReferences...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayRoutes(ctx context.Context, input *ec2.SearchTransitGatewayRoutesInput) ([]ec2types.TransitGatewayRoute, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayRoute, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.SearchTransitGatewayRoutes(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Routes == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Routes...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayRouteTableAssociations(ctx context.Context, input *ec2.GetTransitGatewayRouteTableAssociationsInput) ([]ec2types.TransitGatewayRouteTableAssociation, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayRouteTableAssociation, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.GetTransitGatewayRouteTableAssociations(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Associations == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.GetTransitGatewayRouteTableAssociationsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Associations...)

	}

	return opt, nil
}

func (c *connector) GetTransitGatewayRouteTablePropagations(ctx context.Context, input *ec2.GetTransitGatewayRouteTablePropagationsInput) ([]ec2types.TransitGatewayRouteTablePropagation, error) {
	if c.svc.ec2 == nil {
		c.svc.ec2 = ec2.NewFromConfig(c.svc.config)
	}

	opt := make([]ec2types.TransitGatewayRouteTablePropagation, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ec2.GetTransitGatewayRouteTablePropagations(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TransitGatewayRouteTablePropagations == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ec2.GetTransitGatewayRouteTablePropagationsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TransitGatewayRouteTablePropagations...)

	}

	return opt, nil
}

func (c *connector) GetECSClustersArns(ctx context.Context, input *ecs.ListClustersInput) ([]string, error) {
	if c.svc.ecs == nil {
		c.svc.ecs = ecs.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ecs.ListClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ClusterArns == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ecs.ListClustersInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ClusterArns...)

	}

	return opt, nil
}

func (c *connector) GetECSClusters(ctx context.Context, input *ecs.DescribeClustersInput) ([]ecstypes.Cluster, error) {
	if c.svc.ecs == nil {
		c.svc.ecs = ecs.NewFromConfig(c.svc.config)
	}

	opt := make([]ecstypes.Cluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ecs.DescribeClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Clusters == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Clusters...)

	}

	return opt, nil
}

func (c *connector) GetECSServicesArns(ctx context.Context, input *ecs.ListServicesInput) ([]string, error) {
	if c.svc.ecs == nil {
		c.svc.ecs = ecs.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ecs.ListServices(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ServiceArns == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ecs.ListServicesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ServiceArns...)

	}

	return opt, nil
}

func (c *connector) GetECSServices(ctx context.Context, input *ecs.DescribeServicesInput) ([]ecstypes.Service, error) {
	if c.svc.ecs == nil {
		c.svc.ecs = ecs.NewFromConfig(c.svc.config)
	}

	opt := make([]ecstypes.Service, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ecs.DescribeServices(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Services == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Services...)

	}

	return opt, nil
}

func (c *connector) GetECSTaskDefinitionsArns(ctx context.Context, input *ecs.ListTaskDefinitionsInput) ([]string, error) {
	if c.svc.ecs == nil {
		c.svc.ecs = ecs.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ecs.ListTaskDefinitions(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TaskDefinitionArns == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ecs.ListTaskDefinitionsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TaskDefinitionArns...)

	}

	return opt, nil
}

func (c *connector) GetEFSFileSystems(ctx context.Context, input *efs.DescribeFileSystemsInput) ([]efstypes.FileSystemDescription, error) {
	if c.svc.efs == nil {
		c.svc.efs = efs.NewFromConfig(c.svc.config)
	}

	opt := make([]efstypes.FileSystemDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.efs.DescribeFileSystems(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.FileSystems == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &efs.DescribeFileSystemsInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.FileSystems...)

	}

	return opt, nil
}

func (c *connector) GetEKSCluster(ctx context.Context, input *eks.DescribeClusterInput) (*ekstypes.Cluster, error) {
	if c.svc.eks == nil {
		c.svc.eks = eks.NewFromConfig(c.svc.config)
	}

	var opt *ekstypes.Cluster

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.eks.DescribeCluster(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Cluster == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = o.Cluster

	}

	return opt, nil
}

func (c *connector) GetEKSClusters(ctx context.Context, input *eks.ListClustersInput) ([]string, error) {
	if c.svc.eks == nil {
		c.svc.eks = eks.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.eks.ListClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Clusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &eks.ListClustersInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Clusters...)

	}

	return opt, nil
}

func (c *connector) GetElastiCacheClusters(ctx context.Context, input *elasticache.DescribeCacheClustersInput) ([]elasticachetypes.CacheCluster, error) {
	if c.svc.elasticache == nil {
		c.svc.elasticache = elasticache.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticachetypes.CacheCluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elasticache.DescribeCacheClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.CacheClusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticache.DescribeCacheClustersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.CacheClusters...)

	}

	return opt, nil
}

func (c *connector) GetElastiCacheReplicationGroups(ctx context.Context, input *elasticache.DescribeReplicationGroupsInput) ([]elasticachetypes.ReplicationGroup, error) {
	if c.svc.elasticache == nil {
		c.svc.elasticache = elasticache.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticachetypes.ReplicationGroup, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elasticache.DescribeReplicationGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ReplicationGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticache.DescribeReplicationGroupsInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.ReplicationGroups...)

	}

	return opt, nil
}

func (c *connector) GetElastiCacheTags(ctx context.Context, input *elasticache.ListTagsForResourceInput) ([]elasticachetypes.Tag, error) {
	if c.svc.elasticache == nil {
		c.svc.elasticache = elasticache.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticachetypes.Tag, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elasticache.ListTagsForResource(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TagList == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TagList...)

	}

	return opt, nil
}

func (c *connector) GetElasticBeanstalkApplications(ctx context.Context, input *elasticbeanstalk.DescribeApplicationsInput) ([]elasticbeanstalktypes.ApplicationDescription, error) {
	if c.svc.elasticbeanstalk == nil {
		c.svc.elasticbeanstalk = elasticbeanstalk.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticbeanstalktypes.ApplicationDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elasticbeanstalk.DescribeApplications(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Applications == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Applications...)

	}

	return opt, nil
}

func (c *connector) GetElasticsearchDomainNames(ctx context.Context, input *elasticsearchservice.ListDomainNamesInput) ([]elasticsearchservicetypes.DomainInfo, error) {
	if c.svc.elasticsearchservice == nil {
		c.svc.elasticsearchservice = elasticsearchservice.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticsearchservicetypes.DomainInfo, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elasticsearchservice.ListDomainNames(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DomainNames == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.DomainNames...)

	}

	return opt, nil
}

func (c *connector) GetElasticsearchDomains(ctx context.Context, input *elasticsearchservice.DescribeElasticsearchDomainsInput) ([]elasticsearchservicetypes.ElasticsearchDomainStatus, error) {
	if c.svc.elasticsearchservice == nil {
		c.svc.elasticsearchservice = elasticsearchservice.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticsearchservicetypes.ElasticsearchDomainStatus, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elasticsearchservice.DescribeElasticsearchDomains(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DomainStatusList == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.DomainStatusList...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancerAttributes(ctx context.Context, input *elasticloadbalancing.DescribeLoadBalancerAttributesInput) ([]elasticloadbalancingtypes.AdditionalAttribute, error) {
	if c.svc.elb == nil {
		c.svc.elb = elasticloadbalancing.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingtypes.AdditionalAttribute, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elb.DescribeLoadBalancerAttributes(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.LoadBalancerAttributes == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.LoadBalancerAttributes.AdditionalAttributes...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancers(ctx context.Context, input *elasticloadbalancing.DescribeLoadBalancersInput) ([]elasticloadbalancingtypes.LoadBalancerDescription, error) {
	if c.svc.elb == nil {
		c.svc.elb = elasticloadbalancing.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingtypes.LoadBalancerDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elb.DescribeLoadBalancers(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.LoadBalancerDescriptions == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticloadbalancing.DescribeLoadBalancersInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.LoadBalancerDescriptions...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancerPolicies(ctx context.Context, input *elasticloadbalancing.DescribeLoadBalancerPoliciesInput) ([]elasticloadbalancingtypes.PolicyDescription, error) {
	if c.svc.elb == nil {
		c.svc.elb = elasticloadbalancing.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingtypes.PolicyDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elb.DescribeLoadBalancerPolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.PolicyDescriptions == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.PolicyDescriptions...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersTags(ctx context.Context, input *elasticloadbalancing.DescribeTagsInput) ([]elasticloadbalancingtypes.TagDescription, error) {
	if c.svc.elb == nil {
		c.svc.elb = elasticloadbalancing.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingtypes.TagDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elb.DescribeTags(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TagDescriptions == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TagDescriptions...)

	}

	return opt, nil
}

func (c *connector) GetListenerCertificates(ctx context.Context, input *elasticloadbalancingv2.DescribeListenerCertificatesInput) ([]elasticloadbalancingv2types.Certificate, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.Certificate, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeListenerCertificates(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Certificates == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticloadbalancingv2.DescribeListenerCertificatesInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.Certificates...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2Listeners(ctx context.Context, input *elasticloadbalancingv2.DescribeListenersInput) ([]elasticloadbalancingv2types.Listener, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.Listener, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeListeners(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Listeners == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticloadbalancingv2.DescribeListenersInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.Listeners...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2(ctx context.Context, input *elasticloadbalancingv2.DescribeLoadBalancersInput) ([]elasticloadbalancingv2types.LoadBalancer, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.LoadBalancer, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeLoadBalancers(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.LoadBalancers == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticloadbalancingv2.DescribeLoadBalancersInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.LoadBalancers...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2Tags(ctx context.Context, input *elasticloadbalancingv2.DescribeTagsInput) ([]elasticloadbalancingv2types.TagDescription, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.TagDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeTags(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TagDescriptions == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TagDescriptions...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2TargetGroupAttributes(ctx context.Context, input *elasticloadbalancingv2.DescribeTargetGroupAttributesInput) ([]elasticloadbalancingv2types.TargetGroupAttribute, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.TargetGroupAttribute, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeTargetGroupAttributes(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Attributes == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Attributes...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2TargetGroups(ctx context.Context, input *elasticloadbalancingv2.DescribeTargetGroupsInput) ([]elasticloadbalancingv2types.TargetGroup, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.TargetGroup, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeTargetGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TargetGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticloadbalancingv2.DescribeTargetGroupsInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.TargetGroups...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2TargetHealth(ctx context.Context, input *elasticloadbalancingv2.DescribeTargetHealthInput) ([]elasticloadbalancingv2types.TargetHealthDescription, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.TargetHealthDescription, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeTargetHealth(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TargetHealthDescriptions == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TargetHealthDescriptions...)

	}

	return opt, nil
}

func (c *connector) GetLoadBalancersV2Rules(ctx context.Context, input *elasticloadbalancingv2.DescribeRulesInput) ([]elasticloadbalancingv2types.Rule, error) {
	if c.svc.elbv2 == nil {
		c.svc.elbv2 = elasticloadbalancingv2.NewFromConfig(c.svc.config)
	}

	opt := make([]elasticloadbalancingv2types.Rule, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.elbv2.DescribeRules(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Rules == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &elasticloadbalancingv2.DescribeRulesInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.Rules...)

	}

	return opt, nil
}

func (c *connector) GetEMRClusters(ctx context.Context, input *emr.ListClustersInput) ([]emrtypes.ClusterSummary, error) {
	if c.svc.emr == nil {
		c.svc.emr = emr.NewFromConfig(c.svc.config)
	}

	opt := make([]emrtypes.ClusterSummary, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.emr.ListClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Clusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &emr.ListClustersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Clusters...)

	}

	return opt, nil
}

func (c *connector) GetFSXFileSystems(ctx context.Context, input *fsx.DescribeFileSystemsInput) ([]fsxtypes.FileSystem, error) {
	if c.svc.fsx == nil {
		c.svc.fsx = fsx.NewFromConfig(c.svc.config)
	}

	opt := make([]fsxtypes.FileSystem, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.fsx.DescribeFileSystems(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.FileSystems == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &fsx.DescribeFileSystemsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.FileSystems...)

	}

	return opt, nil
}

func (c *connector) GetGlueDatabases(ctx context.Context, input *glue.GetDatabasesInput) ([]gluetypes.Database, error) {
	if c.svc.glue == nil {
		c.svc.glue = glue.NewFromConfig(c.svc.config)
	}

	opt := make([]gluetypes.Database, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.glue.GetDatabases(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DatabaseList == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &glue.GetDatabasesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.DatabaseList...)

	}

	return opt, nil
}

func (c *connector) GetGlueTables(ctx context.Context, input *glue.GetTablesInput) ([]gluetypes.Table, error) {
	if c.svc.glue == nil {
		c.svc.glue = glue.NewFromConfig(c.svc.config)
	}

	opt := make([]gluetypes.Table, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.glue.GetTables(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TableList == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &glue.GetTablesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TableList...)

	}

	return opt, nil
}

func (c *connector) GetAccessKeys(ctx context.Context, input *iam.ListAccessKeysInput) ([]iamtypes.AccessKeyMetadata, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.AccessKeyMetadata, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListAccessKeys(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.AccessKeyMetadata == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListAccessKeysInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.AccessKeyMetadata...)

	}

	return opt, nil
}

func (c *connector) GetAccountAliases(ctx context.Context, input *iam.ListAccountAliasesInput) ([]string, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListAccountAliases(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.AccountAliases == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListAccountAliasesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.AccountAliases...)

	}

	return opt, nil
}

func (c *connector) GetAccountPasswordPolicy(ctx context.Context, input *iam.GetAccountPasswordPolicyInput) (*iamtypes.PasswordPolicy, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	var opt *iamtypes.PasswordPolicy

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.GetAccountPasswordPolicy(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.PasswordPolicy == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = o.PasswordPolicy

	}

	return opt, nil
}

func (c *connector) GetAttachedGroupPolicies(ctx context.Context, input *iam.ListAttachedGroupPoliciesInput) ([]iamtypes.AttachedPolicy, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.AttachedPolicy, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListAttachedGroupPolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.AttachedPolicies == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListAttachedGroupPoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.AttachedPolicies...)

	}

	return opt, nil
}

func (c *connector) GetAttachedRolePolicies(ctx context.Context, input *iam.ListAttachedRolePoliciesInput) ([]iamtypes.AttachedPolicy, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.AttachedPolicy, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListAttachedRolePolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.AttachedPolicies == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListAttachedRolePoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.AttachedPolicies...)

	}

	return opt, nil
}

func (c *connector) GetAttachedUserPolicies(ctx context.Context, input *iam.ListAttachedUserPoliciesInput) ([]iamtypes.AttachedPolicy, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.AttachedPolicy, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListAttachedUserPolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.AttachedPolicies == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListAttachedUserPoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.AttachedPolicies...)

	}

	return opt, nil
}

func (c *connector) GetGroupUsers(ctx context.Context, input *iam.GetGroupInput) ([]iamtypes.User, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.User, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.GetGroup(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Users == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.GetGroupInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Users...)

	}

	return opt, nil
}

func (c *connector) GetGroupPolicies(ctx context.Context, input *iam.ListGroupPoliciesInput) ([]string, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListGroupPolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.PolicyNames == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListGroupPoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.PolicyNames...)

	}

	return opt, nil
}

func (c *connector) GetGroups(ctx context.Context, input *iam.ListGroupsInput) ([]iamtypes.Group, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.Group, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Groups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListGroupsInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Groups...)

	}

	return opt, nil
}

func (c *connector) GetGroupsForUser(ctx context.Context, input *iam.ListGroupsForUserInput) ([]iamtypes.Group, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.Group, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListGroupsForUser(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Groups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListGroupsForUserInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Groups...)

	}

	return opt, nil
}

func (c *connector) GetInstanceProfiles(ctx context.Context, input *iam.ListInstanceProfilesInput) ([]iamtypes.InstanceProfile, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.InstanceProfile, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListInstanceProfiles(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.InstanceProfiles == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListInstanceProfilesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.InstanceProfiles...)

	}

	return opt, nil
}

func (c *connector) GetOpenIDConnectProviders(ctx context.Context, input *iam.ListOpenIDConnectProvidersInput) ([]iamtypes.OpenIDConnectProviderListEntry, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.OpenIDConnectProviderListEntry, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListOpenIDConnectProviders(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.OpenIDConnectProviderList == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.OpenIDConnectProviderList...)

	}

	return opt, nil
}

func (c *connector) GetPolicies(ctx context.Context, input *iam.ListPoliciesInput) ([]iamtypes.Policy, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.Policy, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListPolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Policies == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListPoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Policies...)

	}

	return opt, nil
}

func (c *connector) GetRolePolicies(ctx context.Context, input *iam.ListRolePoliciesInput) ([]string, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListRolePolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.PolicyNames == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListRolePoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.PolicyNames...)

	}

	return opt, nil
}

func (c *connector) GetRoles(ctx context.Context, input *iam.ListRolesInput) ([]iamtypes.Role, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.Role, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListRoles(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Roles == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListRolesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Roles...)

	}

	return opt, nil
}

func (c *connector) GetSAMLProviders(ctx context.Context, input *iam.ListSAMLProvidersInput) ([]iamtypes.SAMLProviderListEntry, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.SAMLProviderListEntry, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListSAMLProviders(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.SAMLProviderList == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.SAMLProviderList...)

	}

	return opt, nil
}

func (c *connector) GetServerCertificates(ctx context.Context, input *iam.ListServerCertificatesInput) ([]iamtypes.ServerCertificateMetadata, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.ServerCertificateMetadata, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListServerCertificates(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ServerCertificateMetadataList == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListServerCertificatesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.ServerCertificateMetadataList...)

	}

	return opt, nil
}

func (c *connector) GetSSHPublicKeys(ctx context.Context, input *iam.ListSSHPublicKeysInput) ([]iamtypes.SSHPublicKeyMetadata, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.SSHPublicKeyMetadata, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListSSHPublicKeys(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.SSHPublicKeys == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListSSHPublicKeysInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.SSHPublicKeys...)

	}

	return opt, nil
}

func (c *connector) GetUserPolicies(ctx context.Context, input *iam.ListUserPoliciesInput) ([]string, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListUserPolicies(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.PolicyNames == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListUserPoliciesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.PolicyNames...)

	}

	return opt, nil
}

func (c *connector) GetUsers(ctx context.Context, input *iam.ListUsersInput) ([]iamtypes.User, error) {
	if c.svc.iam == nil {
		c.svc.iam = iam.NewFromConfig(c.svc.config)
	}

	opt := make([]iamtypes.User, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.iam.ListUsers(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Users == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &iam.ListUsersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Users...)

	}

	return opt, nil
}

func (c *connector) GetKinesisStreams(ctx context.Context, input *kinesis.ListStreamsInput) ([]string, error) {
	if c.svc.kinesis == nil {
		c.svc.kinesis = kinesis.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.kinesis.ListStreams(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.StreamNames == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.StreamNames...)

	}

	return opt, nil
}

func (c *connector) GetLambdaFunctions(ctx context.Context, input *lambda.ListFunctionsInput) ([]lambdatypes.FunctionConfiguration, error) {
	if c.svc.lambda == nil {
		c.svc.lambda = lambda.NewFromConfig(c.svc.config)
	}

	opt := make([]lambdatypes.FunctionConfiguration, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.lambda.ListFunctions(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Functions == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &lambda.ListFunctionsInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.Functions...)

	}

	return opt, nil
}

func (c *connector) GetLightsailInstances(ctx context.Context, input *lightsail.GetInstancesInput) ([]lightsailtypes.Instance, error) {
	if c.svc.lightsail == nil {
		c.svc.lightsail = lightsail.NewFromConfig(c.svc.config)
	}

	opt := make([]lightsailtypes.Instance, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.lightsail.GetInstances(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Instances == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &lightsail.GetInstancesInput{}
		}
		input.PageToken = o.NextPageToken
		hasNextToken = o.NextPageToken != nil

		opt = append(opt, o.Instances...)

	}

	return opt, nil
}

func (c *connector) GetMediastoreContainers(ctx context.Context, input *mediastore.ListContainersInput) ([]mediastoretypes.Container, error) {
	if c.svc.mediastore == nil {
		c.svc.mediastore = mediastore.NewFromConfig(c.svc.config)
	}

	opt := make([]mediastoretypes.Container, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.mediastore.ListContainers(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Containers == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &mediastore.ListContainersInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Containers...)

	}

	return opt, nil
}

func (c *connector) GetMQBrokers(ctx context.Context, input *mq.ListBrokersInput) ([]mqtypes.BrokerSummary, error) {
	if c.svc.mq == nil {
		c.svc.mq = mq.NewFromConfig(c.svc.config)
	}

	opt := make([]mqtypes.BrokerSummary, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.mq.ListBrokers(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.BrokerSummaries == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &mq.ListBrokersInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.BrokerSummaries...)

	}

	return opt, nil
}

func (c *connector) GetNeptuneDBClusters(ctx context.Context, input *neptune.DescribeDBClustersInput) ([]neptunetypes.DBCluster, error) {
	if c.svc.neptune == nil {
		c.svc.neptune = neptune.NewFromConfig(c.svc.config)
	}

	opt := make([]neptunetypes.DBCluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.neptune.DescribeDBClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DBClusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &neptune.DescribeDBClustersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.DBClusters...)

	}

	return opt, nil
}

func (c *connector) GetRDSDBClusters(ctx context.Context, input *rds.DescribeDBClustersInput) ([]rdstypes.DBCluster, error) {
	if c.svc.rds == nil {
		c.svc.rds = rds.NewFromConfig(c.svc.config)
	}

	opt := make([]rdstypes.DBCluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.rds.DescribeDBClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DBClusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &rds.DescribeDBClustersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.DBClusters...)

	}

	return opt, nil
}

func (c *connector) GetDBInstances(ctx context.Context, input *rds.DescribeDBInstancesInput) ([]rdstypes.DBInstance, error) {
	if c.svc.rds == nil {
		c.svc.rds = rds.NewFromConfig(c.svc.config)
	}

	opt := make([]rdstypes.DBInstance, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.rds.DescribeDBInstances(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DBInstances == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &rds.DescribeDBInstancesInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.DBInstances...)

	}

	return opt, nil
}

func (c *connector) GetDBParameterGroups(ctx context.Context, input *rds.DescribeDBParameterGroupsInput) ([]rdstypes.DBParameterGroup, error) {
	if c.svc.rds == nil {
		c.svc.rds = rds.NewFromConfig(c.svc.config)
	}

	opt := make([]rdstypes.DBParameterGroup, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.rds.DescribeDBParameterGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DBParameterGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &rds.DescribeDBParameterGroupsInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.DBParameterGroups...)

	}

	return opt, nil
}

func (c *connector) GetDBSubnetGroups(ctx context.Context, input *rds.DescribeDBSubnetGroupsInput) ([]rdstypes.DBSubnetGroup, error) {
	if c.svc.rds == nil {
		c.svc.rds = rds.NewFromConfig(c.svc.config)
	}

	opt := make([]rdstypes.DBSubnetGroup, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.rds.DescribeDBSubnetGroups(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DBSubnetGroups == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &rds.DescribeDBSubnetGroupsInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.DBSubnetGroups...)

	}

	return opt, nil
}

func (c *connector) GetRDSGlobalClusters(ctx context.Context, input *rds.DescribeGlobalClustersInput) ([]rdstypes.GlobalCluster, error) {
	if c.svc.rds == nil {
		c.svc.rds = rds.NewFromConfig(c.svc.config)
	}

	opt := make([]rdstypes.GlobalCluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.rds.DescribeGlobalClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.GlobalClusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &rds.DescribeGlobalClustersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.GlobalClusters...)

	}

	return opt, nil
}

func (c *connector) GetDBInstancesTags(ctx context.Context, input *rds.ListTagsForResourceInput) ([]rdstypes.Tag, error) {
	if c.svc.rds == nil {
		c.svc.rds = rds.NewFromConfig(c.svc.config)
	}

	opt := make([]rdstypes.Tag, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.rds.ListTagsForResource(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TagList == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TagList...)

	}

	return opt, nil
}

func (c *connector) GetRedshiftClusters(ctx context.Context, input *redshift.DescribeClustersInput) ([]redshifttypes.Cluster, error) {
	if c.svc.redshift == nil {
		c.svc.redshift = redshift.NewFromConfig(c.svc.config)
	}

	opt := make([]redshifttypes.Cluster, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.redshift.DescribeClusters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Clusters == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &redshift.DescribeClustersInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Clusters...)

	}

	return opt, nil
}

func (c *connector) GetQueryLoggingConfigs(ctx context.Context, input *route53.ListQueryLoggingConfigsInput) ([]route53types.QueryLoggingConfig, error) {
	if c.svc.route53 == nil {
		c.svc.route53 = route53.NewFromConfig(c.svc.config)
	}

	opt := make([]route53types.QueryLoggingConfig, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53.ListQueryLoggingConfigs(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.QueryLoggingConfigs == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53.ListQueryLoggingConfigsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.QueryLoggingConfigs...)

	}

	return opt, nil
}

func (c *connector) GetHealthChecks(ctx context.Context, input *route53.ListHealthChecksInput) ([]route53types.HealthCheck, error) {
	if c.svc.route53 == nil {
		c.svc.route53 = route53.NewFromConfig(c.svc.config)
	}

	opt := make([]route53types.HealthCheck, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53.ListHealthChecks(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.HealthChecks == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53.ListHealthChecksInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.HealthChecks...)

	}

	return opt, nil
}

func (c *connector) GetHostedZones(ctx context.Context, input *route53.ListHostedZonesInput) ([]route53types.HostedZone, error) {
	if c.svc.route53 == nil {
		c.svc.route53 = route53.NewFromConfig(c.svc.config)
	}

	opt := make([]route53types.HostedZone, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53.ListHostedZones(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.HostedZones == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53.ListHostedZonesInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.HostedZones...)

	}

	return opt, nil
}

func (c *connector) GetResourceRecordSets(ctx context.Context, input *route53.ListResourceRecordSetsInput) ([]route53types.ResourceRecordSet, error) {
	if c.svc.route53 == nil {
		c.svc.route53 = route53.NewFromConfig(c.svc.config)
	}

	opt := make([]route53types.ResourceRecordSet, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53.ListResourceRecordSets(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ResourceRecordSets == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53.ListResourceRecordSetsInput{}
		}
		input.StartRecordName = o.NextRecordName
		hasNextToken = o.NextRecordName != nil

		opt = append(opt, o.ResourceRecordSets...)

	}

	return opt, nil
}

func (c *connector) GetReusableDelegationSets(ctx context.Context, input *route53.ListReusableDelegationSetsInput) ([]route53types.DelegationSet, error) {
	if c.svc.route53 == nil {
		c.svc.route53 = route53.NewFromConfig(c.svc.config)
	}

	opt := make([]route53types.DelegationSet, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53.ListReusableDelegationSets(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.DelegationSets == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53.ListReusableDelegationSetsInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.DelegationSets...)

	}

	return opt, nil
}

func (c *connector) GetVPCAssociationAuthorizations(ctx context.Context, input *route53.ListVPCAssociationAuthorizationsInput) ([]route53types.VPC, error) {
	if c.svc.route53 == nil {
		c.svc.route53 = route53.NewFromConfig(c.svc.config)
	}

	opt := make([]route53types.VPC, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53.ListVPCAssociationAuthorizations(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.VPCs == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53.ListVPCAssociationAuthorizationsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.VPCs...)

	}

	return opt, nil
}

func (c *connector) GetResolverEndpoints(ctx context.Context, input *route53resolver.ListResolverEndpointsInput) ([]route53resolvertypes.ResolverEndpoint, error) {
	if c.svc.route53resolver == nil {
		c.svc.route53resolver = route53resolver.NewFromConfig(c.svc.config)
	}

	opt := make([]route53resolvertypes.ResolverEndpoint, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53resolver.ListResolverEndpoints(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ResolverEndpoints == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53resolver.ListResolverEndpointsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ResolverEndpoints...)

	}

	return opt, nil
}

func (c *connector) GetResolverRuleAssociations(ctx context.Context, input *route53resolver.ListResolverRuleAssociationsInput) ([]route53resolvertypes.ResolverRuleAssociation, error) {
	if c.svc.route53resolver == nil {
		c.svc.route53resolver = route53resolver.NewFromConfig(c.svc.config)
	}

	opt := make([]route53resolvertypes.ResolverRuleAssociation, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53resolver.ListResolverRuleAssociations(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ResolverRuleAssociations == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53resolver.ListResolverRuleAssociationsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ResolverRuleAssociations...)

	}

	return opt, nil
}

func (c *connector) GetResolverRules(ctx context.Context, input *route53resolver.ListResolverRulesInput) ([]route53resolvertypes.ResolverRule, error) {
	if c.svc.route53resolver == nil {
		c.svc.route53resolver = route53resolver.NewFromConfig(c.svc.config)
	}

	opt := make([]route53resolvertypes.ResolverRule, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.route53resolver.ListResolverRules(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ResolverRules == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &route53resolver.ListResolverRulesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ResolverRules...)

	}

	return opt, nil
}

func (c *connector) GetBucketTags(ctx context.Context, input *s3.GetBucketTaggingInput) ([]s3types.Tag, error) {
	if c.svc.s3 == nil {
		c.svc.s3 = s3.NewFromConfig(c.svc.config)
	}

	opt := make([]s3types.Tag, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.s3.GetBucketTagging(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TagSet == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TagSet...)

	}

	return opt, nil
}

func (c *connector) ListObjects(ctx context.Context, input *s3.ListObjectsInput) ([]s3types.Object, error) {
	if c.svc.s3 == nil {
		c.svc.s3 = s3.NewFromConfig(c.svc.config)
	}

	opt := make([]s3types.Object, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.s3.ListObjects(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Contents == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &s3.ListObjectsInput{}
		}
		input.Marker = o.NextMarker
		hasNextToken = o.NextMarker != nil

		opt = append(opt, o.Contents...)

	}

	return opt, nil
}

func (c *connector) GetObjectsTags(ctx context.Context, input *s3.GetObjectTaggingInput) ([]s3types.Tag, error) {
	if c.svc.s3 == nil {
		c.svc.s3 = s3.NewFromConfig(c.svc.config)
	}

	opt := make([]s3types.Tag, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.s3.GetObjectTagging(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TagSet == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.TagSet...)

	}

	return opt, nil
}

func (c *connector) GetActiveReceiptRuleSet(ctx context.Context, input *ses.DescribeActiveReceiptRuleSetInput) (*string, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	var opt *string

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.DescribeActiveReceiptRuleSet(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Metadata == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = o.Metadata.Name

	}

	return opt, nil
}

func (c *connector) GetActiveReceiptRulesSet(ctx context.Context, input *ses.DescribeActiveReceiptRuleSetInput) ([]sestypes.ReceiptRule, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	opt := make([]sestypes.ReceiptRule, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.DescribeActiveReceiptRuleSet(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Rules == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Rules...)

	}

	return opt, nil
}

func (c *connector) GetConfigurationSets(ctx context.Context, input *ses.ListConfigurationSetsInput) ([]sestypes.ConfigurationSet, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	opt := make([]sestypes.ConfigurationSet, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.ListConfigurationSets(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.ConfigurationSets == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ses.ListConfigurationSetsInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.ConfigurationSets...)

	}

	return opt, nil
}

func (c *connector) GetIdentities(ctx context.Context, input *ses.ListIdentitiesInput) ([]string, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.ListIdentities(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Identities == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ses.ListIdentitiesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.Identities...)

	}

	return opt, nil
}

func (c *connector) GetIdentityNotificationAttributes(ctx context.Context, input *ses.GetIdentityNotificationAttributesInput) (map[string]sestypes.IdentityNotificationAttributes, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	opt := make(map[string]sestypes.IdentityNotificationAttributes, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.GetIdentityNotificationAttributes(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.NotificationAttributes == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = o.NotificationAttributes

	}

	return opt, nil
}

func (c *connector) GetReceiptFilters(ctx context.Context, input *ses.ListReceiptFiltersInput) ([]sestypes.ReceiptFilter, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	opt := make([]sestypes.ReceiptFilter, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.ListReceiptFilters(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Filters == nil {
			hasNextToken = false
			continue
		}

		hasNextToken = false

		opt = append(opt, o.Filters...)

	}

	return opt, nil
}

func (c *connector) GetTemplates(ctx context.Context, input *ses.ListTemplatesInput) ([]sestypes.TemplateMetadata, error) {
	if c.svc.ses == nil {
		c.svc.ses = ses.NewFromConfig(c.svc.config)
	}

	opt := make([]sestypes.TemplateMetadata, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.ses.ListTemplates(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.TemplatesMetadata == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &ses.ListTemplatesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.TemplatesMetadata...)

	}

	return opt, nil
}

func (c *connector) GetSQSQueues(ctx context.Context, input *sqs.ListQueuesInput) ([]string, error) {
	if c.svc.sqs == nil {
		c.svc.sqs = sqs.NewFromConfig(c.svc.config)
	}

	opt := make([]string, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.sqs.ListQueues(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.QueueUrls == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &sqs.ListQueuesInput{}
		}
		input.NextToken = o.NextToken
		hasNextToken = o.NextToken != nil

		opt = append(opt, o.QueueUrls...)

	}

	return opt, nil
}

func (c *connector) GetStorageGatewayGateways(ctx context.Context, input *storagegateway.ListGatewaysInput) ([]storagegatewaytypes.GatewayInfo, error) {
	if c.svc.storagegateway == nil {
		c.svc.storagegateway = storagegateway.NewFromConfig(c.svc.config)
	}

	opt := make([]storagegatewaytypes.GatewayInfo, 0)

	hasNextToken := true
	for hasNextToken {
		o, err := c.svc.storagegateway.ListGateways(ctx, input)
		if err != nil {
			return nil, err
		}
		if o.Gateways == nil {
			hasNextToken = false
			continue
		}

		if input == nil {
			input = &storagegateway.ListGatewaysInput{}
		}
		input.Marker = o.Marker
		hasNextToken = o.Marker != nil

		opt = append(opt, o.Gateways...)

	}

	return opt, nil
}
